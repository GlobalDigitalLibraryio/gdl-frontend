const { join } = require('path');
const util = require('util');
const fs = require('fs');
const glob = require('glob');
const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);

const nextUrlPrefix = '/_next/';
const excludeFiles = ['react-loadable-manifest.json', 'build-manifest.json'];
const manifestDest = 'precache-manifest.*.js';
const manifestImportRegex = /(,\s*(\r\n|\r|\n)\s*)?"precache-manifest\.[^.]*\.js"(,\s*)?/;

// Based on https://github.com/hanford/next-offline

/**
 * Workbox option for manifest transforms doesn't apply to assets generated by webpack.
 * This is something we want to do because we need to alter the URLs, and we also want to filter
 * the precache files.
 *
 * This is a small webpack plugin workaround that grabs the generated preache manifest and inlines it into the serviceworker
 *
 * This will probably be fixed in version 4 (https://github.com/GoogleChrome/workbox/issues/1591) of workbox,
 * at which point we can probably move the transform into the workbox config and get rid of this workaround.
 */
class InlinePrecacheManifest {
  constructor(opts) {
    this.opts = opts;
  }

  apply(compiler) {
    compiler.plugin(
      'done',
      async compilation => {
        const { outputPath, swDest, urlPrefix, buildId } = this.opts;
        const manifestFilePath = join(outputPath, manifestDest);
        const swFilePath = join(outputPath, swDest);

        const originalManifest = await getOriginalManifest(manifestFilePath);
        const newManifest = buildNextManifest(originalManifest, urlPrefix);

        // Add our offline page so we have some HTML to fall back on if we're offline. See service-worker.js
        newManifest.push({ url: '/offline', revision: buildId });

        await inlineManifest(newManifest, swFilePath);
      },
      err => {
        throw new Error(`Precached failed: ${err.toString()}`);
      }
    );
  }
}

function getOriginalManifest(manifestFilePath) {
  return new Promise((resolve, reject) => {
    glob(manifestFilePath, async (err, files = []) => {
      if (err) {
        return reject(err);
      }

      // Pick first and only as we've clean old ones.
      const file = await readFile(files[0], 'utf-8');
      // Execute file with a self variable in the scope/context.
      const self = {};
      new Function('self', file)(self); // eslint-disable-line no-new-func

      resolve(self.__precacheManifest);
    });
  });
}

function buildNextManifest(originalManifest, urlPrefix = '') {
  return originalManifest
    .filter(entry => !excludeFiles.includes(entry.url))
    .map(entry => ({
      url: `${urlPrefix}${nextUrlPrefix}${entry.url}`
    }));
}

async function inlineManifest(manifest, swFilePath) {
  const originalSw = await readFile(swFilePath, 'utf-8');

  // Prepend/inline newly generated precache manifest and remove import for old one.
  const newSw = `self.__precacheManifest = ${JSON.stringify(
    manifest,
    null,
    2
  )};\n\n${originalSw.replace(manifestImportRegex, '')}`;

  await writeFile(swFilePath, newSw, 'utf8');
}

module.exports = InlinePrecacheManifest;
